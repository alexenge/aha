---
title             : "The title"
shorttitle        : "Title"

author: 
  - name          : "First Author"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "Postal address"
    email         : "my@email.com"
    role:         # Contributorship roles (e.g., CRediT, https://casrai.org/credit/)
      - Conceptualization
      - Writing - Original Draft Preparation
      - Writing - Review & Editing
  - name          : "Ernst-August Doelle"
    affiliation   : "1,2"
    role:
      - Writing - Review & Editing

affiliation:
  - id            : "1"
    institution   : "Wilhelm-Wundt-University"
  - id            : "2"
    institution   : "Konstanz Business School"

authornote: |
  Add complete departmental affiliations for each author here. Each new line herein must be indented, like this line.

  Enter author note here.

abstract: |
  One or two sentences providing a **basic introduction** to the field,  comprehensible to a scientist in any discipline.
  
  Two to three sentences of **more detailed background**, comprehensible  to scientists in related disciplines.
  
  One sentence clearly stating the **general problem** being addressed by  this particular study.
  
  One sentence summarizing the main result (with the words "**here we show**" or their equivalent).
  
  Two or three sentences explaining what the **main result** reveals in direct comparison to what was thought to be the case previously, or how the  main result adds to previous knowledge.
  
  One or two sentences to put the results into a more **general context**.
  
  Two or three sentences to provide a **broader perspective**, readily comprehensible to a scientist in any discipline.
  
  <!-- https://tinyurl.com/ybremelq -->
  
keywords          : "keywords"
wordcount         : "X"

bibliography      : ["r-references.bib"]

floatsintext      : yes
figurelist        : no
tablelist         : no
footnotelist      : no
linenumbers       : yes
mask              : no
draft             : no

csl               : "apa.csl"
documentclass     : "apa7"
classoption       : "man"
output            : papaja::apa6_pdf
---

```{r setup, include=FALSE}
# Load packages
library(papaja)
library(reticulate)
library(MASS)
library(Matrix)
library(lme4)
library(lmerTest)
library(buildmer)
library(emmeans)
library(magrittr)
library(tidyverse)
library(cowplot)

# Chunk options
knitr::opts_chunk$set(include = FALSE, fig.align = "center", fig.out = "100%", fig.width = 10)

# Conda environment for Python
#use_condaenv("r-reticulate", required = TRUE)
renv::use_python(python = "/Users/alexander/opt/anaconda3/bin/python", type = "conda")

# Bibliography file
r_refs("manuscript/r-references.bib")
```

```{r exp1-preparation}
# Function for processing behavioral data
preproc_behav <- function(txt_fname){
  # Read log file
  dat <- suppressMessages(suppressWarnings(read_tsv(txt_fname)))
  # Rename some columns
  dat %<>% rename(participant = VPNummer, item = StimID) %>%
    # Add a column for the part of the experiment
    mutate(part = as_factor(Wdh - min(Wdh) + 1)) %>%
    # Remove filler stimuli (i.e. well-known objects)
    filter(bek_unbek != "bekannt")
  # Assign stimuli to conditions based on keywords and button presses
  known <- dat %>% filter(part == "1" & Tastencode %in% c(201, 251)) %>% pull(item)
  insight <- dat %>% filter(part == "2" & grepl("richtig", Bed) & Tastencode %in% c(201, 202, 251, 252)) %>% pull(item)
  naive <- dat %>% filter(part == "2" & grepl("falsch", Bed) & Tastencode %in% c(203, 204, 253, 254)) %>% pull(item)
  # Create a new condition column, excluding trials with knwon stimuli or without condition
  dat %<>% mutate(condition = as_factor(case_when(item %in% known ~ "Excl_known",
                                                  item %in% insight ~ "Insight",
                                                  item %in% naive ~ "Naive",
                                                  TRUE ~ "Excl_cond")))
  # In Experiment 3, we need an additional column for position (upright vs. inverted)
  if("richtig_inv" %in% dat$Bed){
    dat %<>% mutate(position = as_factor(ifelse(grepl("inv", Bed), "Inverted", "Upright"))) %>%
      # Return only relevant columns
      select(part, position, condition, participant, item, RT)
  } else {
    dat %<>% select(part, condition, participant, item, RT)}
  return(dat)}

# List of filenames for behavioral data
fnames_exp1 <- list.files("data/exp1/RT", pattern = ".txt", full.names = TRUE)

# Apply the preprocessing function
data_exp1 <- map(fnames_exp1, preproc_behav)

# Tabulate percentage of stimuli per condition
(stims_exp1 <- bind_rows(data_exp1) %>% filter(condition != "Excl_cond") %>% 
    group_by(participant, condition) %>% tally() %>%
    group_by(condition) %>% summarise(mean = mean(n)/(60*3)) %>% # 60 items per condition
    mutate(mean = if_else(condition == "Excl_known", mean/2, mean))) # 120 items in total
```

```{python exp1-preprocessing}
# Import libraries
import mne
import glob
import os

# Define parameters for EEG preprocessing
preproc_params = dict(n_components=15, method='fastica',           # ICA parameters
                      l_freq=0.1, h_freq=30,                       # Filter edges
                      event_id={'match': 221, 'mismatch': 222},    # EEG triggers
                      tmin=-0.5, tmax=1.498,                       # Length of epochs
                      baseline=(-0.2,0),                           # Baseline correction
                      reject=dict(eeg=200e-6))                     # Rejection threshold

# # Debug
# locals().update(preproc_params)
# vhdr_fname = 'data/exp1/EEG/Vp0001.vhdr'
# metadata = metadata_exp1[0]

# Define preprocessing function
def preproc(vhdr_fname, metadata, n_components, method, l_freq, h_freq, event_id, tmin, tmax, baseline, reject):
  # Load EEG data
  raw = mne.io.read_raw_brainvision(vhdr_fname, preload=True)
  # Create new virtual EOG channels
  raw = mne.set_bipolar_reference(raw, 'Auge_u', 'Fp1', ch_name='VEOG', drop_refs=False)
  raw = mne.set_bipolar_reference(raw, 'F9', 'F10', ch_name='HEOG', drop_refs=False)
  raw.set_channel_types(mapping={'VEOG': 'eog', 'HEOG': 'eog'})
  # Add EasyCap electrode layout, removing any excessive channels
  montage = mne.channels.make_standard_montage('easycap-M1')
  raw.drop_channels(list(set(raw.ch_names) - set(montage.ch_names) - set(['VEOG', 'HEOG'])))
  raw.set_montage(montage=montage)
  # Re-reference to common average
  raw, _ = mne.set_eeg_reference(raw, 'average')
  # Run ICA on a copy of the data
  filt_raw = raw.copy()
  filt_raw.load_data().filter(l_freq=1, h_freq=None)
  ica = mne.preprocessing.ICA(n_components=n_components, random_state=12345, method=method)
  ica.fit(filt_raw)
  # Remove bad components based on correlations with EOG
  eog_indices, eog_scores = ica.find_bads_eog(raw)
  ica.exclude = eog_indices
  raw = ica.apply(raw)
  # Apply band-pass filter
  raw = raw.filter(l_freq=l_freq, h_freq=h_freq)
  # Epoching including baseline correction
  events, _ = mne.events_from_annotations(raw, verbose=False)
  epochs = mne.Epochs(raw, events=events, event_id=event_id, tmin=tmin, tmax=tmax, baseline=baseline, preload=True)
  # Add behavioral data
  epochs.metadata = metadata
  # Reject bad epochs
  epochs = epochs.drop_bad(reject=reject)
  
  # # Autoreject                    
  # import autoreject
  # 
  # ar = autoreject.AutoReject(thresh_method='random_search', verbose=False)
  # epochs = ar.fit_transform(epochs)
  # 
  # ransac = autoreject.Ransac(verbose=False)
  # epochs = ransac.fit_transform(epochs)
  # 
  # reject = autoreject.get_rejection_threshold(epochs)
  # epochs = epochs.drop_bad(reject=reject)
  
  return epochs

# List of raw EEG filenames
fnames_exp1 = sorted(glob.glob('data/exp1/EEG/*.vhdr'))

# Import behavioral data from R
metadata_exp1 = r.data_exp1

# Check if preprocessing was done already (delete the file to re-run)
if os.path.exists('output/exp1-epo.fif'):
  # Load preprocessed data from file
  epochs_exp1 = mne.read_epochs('output/exp1-epo.fif', preload=True)
else:
  # Apply the preprocessing function
  epochs_exp1 = [preproc(vhdr_fname=fname, metadata=meta, **preproc_params) for fname, meta in zip(fnames_exp1, metadata_exp1)]
  # Combine epochs into a single data set
  epochs_exp1 = mne.concatenate_epochs(epochs_exp1)
  # Backup epochs to the output folder
  epochs_exp1.save('output/exp1-epo.fif')

# # Get indices of bad epochs despite ICA
# rej_exp1 = epochs_exp1.drop_log
# rej_exp1[:] = [item for item in rej_exp1 if item != ['IGNORED']]
# rej_exp1 = [i for i in range(len(rej_exp1)) if rej_exp1[i] != []]

# Define function to compute grand-averaged ERPs per condition
def compute_evokeds(epochs):
  evokeds = dict()
  evokeds_dat = dict()
  # Each part becomes a dictionary of conditions
  for pt in ['1', '2', '3']:
    evokeds['Pt' + pt] = dict()
    evokeds_dat['Pt' + pt] = dict()
    # Each condition becomes a list of participants
    for cn in ['Insight', 'Naive']:
      evokeds['Pt' + pt][cn] = list()
      evokeds_dat['Pt' + pt][cn] = list()
      # For every participant we average trials separately for all parts and conditions
      for vp in epochs.metadata['participant'].unique():
        query = 'participant == "' + vp + '" and part == "' + pt + '" and condition == "' + cn + '"'
        evokeds['Pt' + pt][cn].append(epochs[query].average())
      # Compute grand averages across participants for this part and condition
      evokeds['Pt' + pt][cn] = mne.grand_average(evokeds['Pt' + pt][cn])
      # Export only the actual data for R
      evokeds_dat['Pt' + pt][cn] = evokeds['Pt' + pt][cn].data
  return(evokeds, evokeds_dat)

# Apply the function to compute grand averages
evokeds_exp1, evokeds_dat_exp1 = compute_evokeds(epochs=epochs_exp1)

# Export electrode positions for R
elpos = epochs_exp1._get_channel_positions()

# # Plot evoked potentials
# mne.viz.plot_compare_evokeds(evokeds=evokeds_exp1['Pt1'], picks='P8'); plt.show()
# mne.viz.plot_evoked_topomap(evoked=evokeds_exp1['Pt2']['Insight']-evokeds_exp1['Pt2']['Naive'])
# evokeds_exp1['Pt2']['Insight'].data = evokeds_exp1['Pt2']['Insight'].data - evokeds_exp1['Pt2']['Naive'].data
# evokeds_exp1['Pt2']['Insight'].plot_topomap(times=[0.125, 0.175, 0.5], average=0.05, vmin=-1, vmax=1, cmap='viridis'); plt.show()
```
    
```{r exp1-analysis}
# Re-import behavioral data
data_exp1 <- py$epochs_exp1$metadata

# Factorize some columns
data_exp1 %<>% mutate(part = factor(part, levels = c("1", "2", "3")),
                      condition = factor(condition, levels = c("Insight", "Naive", "Excl_known", "Excl_cond")),
                      participant = factor(participant), item = factor(item))

# Check number of rejected epochs
rejected_exp1 <- data_exp1 %>% group_by(participant) %>% tally() %>% mutate(n = 360 - n) %>% pull(n)
mean(rejected_exp1); median(rejected_exp1); range(rejected_exp1)

# Create vectors with sample time points (in ms) and electrodes
tmin <- py$preproc_params$tmin*1000
tmax <- py$preproc_params$tmax*1000
sfreq <- py$epochs_exp1$info['sfreq']
times <- seq(tmin, tmax, 1000/sfreq)
els <- py$epochs_exp1$ch_names

# Define ERP components of interest
comps <- tibble(name = c("P1", "N1", "N400"),
                start = c(100, 150, 400),
                stop = c(150, 200, 700),
                roi = list(c("PO3", "PO4", "POz", "O1", "O2", "Oz"),
                           c("P7", "P8", "PO7", "PO8", "PO9", "PO10"),
                           c("C1", "C2", "Cz", "CP1", "CP2", "CPz")))

# Define function to compute single-trial ERPs
compute_erps <- function(epochs, els, name, start, stop, roi){
  erps <- epochs[, which(els %in% roi), which(times %in% start:stop)]
  erps <- apply(erps, 1, mean, na.rm = TRUE)
  return(erps)}

# Check if ERPs were computed already (delete the file to re-run)
if (file.exists("output/exp1-erps.RDS")){
  # Load ERPs from file
  data_exp1 <- readRDS("output/exp1-erps.RDS")
} else {
  # Import epochs from Python, converting Volts to Microvolts
  epochs_exp1 <- py$epochs_exp1$get_data()*1e6
  # Apply the ERP function and save to output folder
  data_exp1 <- pmap_dfc(comps, compute_erps, epochs = epochs_exp1, els = els) %>%
    set_names(comps$name) %>% cbind(data_exp1, .) %T>% saveRDS("output/exp1-erps.RDS")}

# Remove any trials that don't beling to either of the two conditions
data_exp1 %<>% filter(condition %in% c("Insight", "Naive")) %>% droplevels()

# Sliding difference coding for condition (insight-naive) and part (2-1, 3-1)
t(contrasts_condition <- t(cbind(c("Insight" = 1, "Naive" = -1))))
t(contrasts_part <- t(cbind(c("1" = -1, "2" = 1, "3" = 0),
                            c("1" = 0, "2" = -1, "3" = 1))))
contrasts(data_exp1$condition) <- ginv(contrasts_condition)
contrasts(data_exp1$part) <- ginv(contrasts_part)

# Formula and parameters for linear mixed-effects regression models (LMMs)
form_exp12 <- tabulate.formula(~ part*condition + (part*condition|participant) + (part*condition|item))
form_exp12 %<>% mutate(block = replace(block, is.na(grouping), "fixed"))
ctrl_params <- lmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))

# Formula for follow-up contrasts
specs_exp12 = pairwise ~ condition|part

# Define function to compute LMMs and contrasts for each component
compute_models <- function(dep, formula, data, control, specs){
  browser()
  build <- buildmer(dep = dep, formula = formula, data = data, ddf = "Satterthwaite", calc.anova = TRUE, control = control)
  emm_options(lmer.df = "Satterthwaite", lmerTest.limit = Inf)
  conts <- emmeans(build@model, specs = specs, infer = TRUE, data = data)$contrasts %>% as.data.frame()
  mod <- list("model" = build@model, "anova" = build@anova, "summary" = build@summary, "contrasts" = conts)
  return(mod)}

# Check if models were computed already (delete the file to re-run)
if (file.exists("output/exp1-stats.RDS")){
  # Load models from file
  models_exp1 <- readRDS("output/exp1-stats.RDS")
} else {
  # Apply the modelling function and save to output folder
  models_exp1 <- map(comps$name, compute_models, formula = form_exp12, data = data_exp1, control = ctrl_params,
                     specs = specs_exp12) %>% set_names(comps$name) %T>% saveRDS("output/exp1-stats.RDS")}

# Store significance levels for plotting
stars_exp1 = list(P1 = c(Pt1 = NA, Pt2 = NA, Pt3 = "*"),
                  N1 = c(Pt1 = NA, Pt2 = "**", Pt3 = NA),
                  N400 = c(Pt1 = NA, Pt2 = "***", Pt3 = "**"))
```

```{r exp1-output, include=TRUE, results="asis", fig.height=12}
# Check if models were computed already (delete the file to re-run)
if (file.exists("output/exp1-stats.RDS")){
  # Load models from file
  models_exp1 <- readRDS("output/exp1-stats.RDS")
} else {
  # Apply the modelling function and save to output folder
  models_exp1 <- map(comps$name, compute_models, formula = form_exp12, data = data_exp1, control = ctrl_params,
                     specs = specs_exp12) %>% set_names(comps$name) %>% saveRDS("output/exp1-stats.RDS")}

# Define function to create ANOVA-style table
create_table <- function(models, stub.anova, stub.contrasts, caption, note){
  anov <- map(models, function(model){
    data.frame("stat" = paste0(format(round(model$anova$`F value`, 2), trim = FALSE, nsmall = 2), " (", model$anova$NumDF,
                               ", ", format(round(model$anova$DenDF, 1), trim = FALSE, nsmall = 1), ")"),
               "p" = format(round(model$anova$`Pr(>F)`, 3), trim = FALSE, nsmall = 3)) %>%
      mutate(p = ifelse(p == "0.000", "<.001", substr(p, 2, nchar(p))))}) %>%
    bind_cols() %>% set_rownames(c(stub.anova))
  cnames <- c("\\textit{Fixed effects}", rep(c("\\textit{F} (\\textit{df})", "p" = "\\textit{p}"), 3))
  conts <- map(models, function(model){
    data.frame("stat" = paste0(format(round(model$contrasts$estimate, 2), trim = FALSE, nsmall = 2), " [",
                               format(round(model$contrasts$lower.CL, 2), trim = FALSE, nsmall = 2), ", ",
                               format(round(model$contrasts$upper.CL, 2), trim = FALSE, nsmall = 2), "]"),
               "p" = format(round(model$contrasts$`p.value`, 3), trim = FALSE, nsmall = 3)) %>%
      mutate(p = ifelse(p == "0.000", "<.001", substr(p, 2, nchar(p)))) %>%
      add_row("stat" = "Est. [95% CI]", "p" = "\\textit{p}", .before = 1)}) %>% 
    bind_cols() %>% set_rownames(c("\\textit{Insight $-$  naive}", stub.contrasts))
  apa_table(list(anov, conts), col.names = cnames, escape = FALSE,
            col_spanners = list("\\textbf{P1}" = 2:3, "\\textbf{N1}" = 4:5, "\\textbf{N400}" = 6:7),
            midrules = c(nrow(anov) + 1), font_size = "footnotesize", align = "lcccccc",
            caption = caption, note = note)}

# Apply the function to print the table
create_table(models_exp1, stub.anova = c("Part", "Insight", "Pt. × ins."),
             stub.contrasts = c("Part 1", "Part 2", "Part 3"),
             caption = "Results of linear mixed-effects regression models for Experiment 1",
             note = "Pt. = part, ins. = insight, est. = estimate, CI = confidence interval.")

# Import grand averaged evoked potentials from Python
evokeds_exp1 <- py$evokeds_dat_exp1

# Retrive locations for the relevant electrodes from standard montage
montage <- py$evokeds_exp1$Pt1$Insight$ch_names %>% as_tibble() %>% rename(electrode = value) %>%
  left_join(read.delim("renv/python/condaenvs/renv-python/lib/python3.8/site-packages/mne/channels/data/montages/easycap-M1.txt") %>% 
              as_tibble() %>% rename(electrode = Site)) %>%
  mutate(x = eegUtils:::deg2rad(Theta) * cos(eegUtils:::deg2rad(Phi)),
         y = eegUtils:::deg2rad(Theta) * sin(eegUtils:::deg2rad(Phi)))

# Define function to plot trial structure
plot_trial <- function(){
  colour_insight <- viridisLite::viridis(1, begin = 0, end = 0)
  colour_naive <- viridisLite::viridis(1, begin = 0.5, end = 0.5)
  trial_pt1 <- ggplot() + coord_fixed() + theme_void() + xlim(c(0, 74)) + ylim(c(-5, 68)) +
    geom_text(aes(x = 37, y = 68, label = "Part 1"), size = 14/.pt, family = "Helvetica", fontface = "bold") +
    geom_rect(aes(xmin = 18, xmax = 38, ymin = 13, ymax = 33), color = "black", fill = "white") +
    geom_text(aes(x = 28, y = 23, label = "+"), size = 5, family = "Helvetica", fontface = "bold") +
    geom_text(aes(x = 28, y = 10, label = "0.5 s"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_rect(aes(xmin = 36, xmax = 56, ymin = 26, ymax = 46), color = "black", fill = "white") +
    draw_image("materials/exp1/potato_masher.png", x = 36, y = 26, width = 20, height = 20) +
    geom_text(aes(x = 47, y = 23, label = "max. 3 s"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_segment(aes(x = 46, y = 13, xend = 56, yend = 20.222), arrow = arrow(length = unit(0.2, "cm")), color = "black")
  trial_pt2 <- ggplot() + coord_fixed() + theme_void() + xlim(c(0, 74)) + ylim(c(-5, 68)) +
    geom_text(aes(x = 37, y = 68, label = "Part 2"), size = 14/.pt, family = "Helvetica", fontface = "bold") +
    geom_rect(aes(xmin = 0, xmax = 20, ymin = 0, ymax = 20), color = "black", fill = "white") +
    geom_text(aes(x = 10, y = 10.5, label = "+"), size = 5, family = "Helvetica", fontface = "bold") +
    geom_text(aes(x = 10, y = -3, label = "0.5 s"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_rect(aes(xmin = 18, xmax = 38, ymin = 13, ymax = 33), color = colour_insight, fill = "white") +
    geom_text(aes(x = 28, y = 23, label = "Potato\nmashing"), color = colour_insight, size = 10/.pt, family = "Helvetica") +
    geom_text(aes(x = 28, y = 10, label = "2.5 s"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_rect(aes(xmin = 18, xmax = 38, ymin = 39, ymax = 59), color = colour_naive, fill = "white") +
    geom_text(aes(x = 28, y = 49, label = "Message\nmorsing"), color = colour_naive, size = 10/.pt, family = "Helvetica") +
    geom_text(aes(x = 28, y = 36, label = "or"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_rect(aes(xmin = 36, xmax = 56, ymin = 26, ymax = 46), color = "black", fill = "white") +
    geom_text(aes(x = 46, y = 34, label = "*"), size = 8, family = "Helvetica") +
    geom_text(aes(x = 46, y = 23, label = "0.5 s"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_rect(aes(xmin = 54, xmax = 74, ymin = 39, ymax = 59), color = "black", fill = "white") +
    draw_image("materials/exp1/potato_masher.png", x = 54, y = 39, width = 20, height = 20) +
    geom_text(aes(x = 65, y = 36, label = "max. 3 s"), color = "black", size = 10/.pt, family = "Helvetica", lineheight = 1) +
    geom_segment(aes(x = 28, y = 0, xend = 74, yend = 33.222), arrow = arrow(length = unit(0.2, "cm")), color = "black")
  trial_pt3 <- ggplot() + coord_fixed() + theme_void() + xlim(c(0, 74)) + ylim(c(-5, 68)) +
    geom_text(aes(x = 37, y = 68, label = "Part 3"), size = 14/.pt, family = "Helvetica", fontface = "bold") +
    geom_rect(aes(xmin = 18, xmax = 38, ymin = 13, ymax = 33), color = "black", fill = "white") +
    geom_text(aes(x = 28, y = 23, label = "+"), size = 5, family = "Helvetica", fontface = "bold") +
    geom_text(aes(x = 28, y = 10, label = "0.5 s"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_rect(aes(xmin = 36, xmax = 56, ymin = 26, ymax = 46), color = "black", fill = "white") +
    draw_image("materials/exp1/potato_masher.png", x = 36, y = 26, width = 20, height = 20) +
    geom_text(aes(x = 47, y = 23, label = "max. 3 s"), color = "black", size = 10/.pt, family = "Helvetica") +
    geom_segment(aes(x = 46, y = 13, xend = 56, yend = 20.222), arrow = arrow(length = unit(0.2, "cm")), color = "black")
  plot_grid(trial_pt1, NULL, trial_pt2, NULL, trial_pt3, nrow = 1, rel_widths = c(10, 1, 10, 1, 10))}

# Define function to plot mean ERP amplitudes
plot_bars <- function(data, stars, ymin){
  parts <- map(unique(data$part), function(part){
    # For which components in the current part do we have a significant effect?
    sig <- map(stars, paste0("Pt", part)) %>% as.data.frame() %>% t() %>% as.data.frame() %>%
      set_colnames("label") %>% rownames_to_column("comp") %>% na.omit()
    # Create bar plot for the current part
    map(c("P1", "N1", "N400"), function(comp){
      p <- data %>% filter(part == !!part) %>%
        Rmisc::summarySEwithin(measurevar = comp, withinvars = "condition", idvar = "participant") %>%
        mutate(comp = !!comp) %>% rename(amplitude = !!comp)}) %>% bind_rows() %>%
      mutate(comp = fct_relevel(comp, "P1", "N1", "N400")) %>%
      ggplot(aes(x = comp, y = amplitude, fill = condition)) +
      # geom_bar(aes(fill = condition), stat = "identity", position = position_dodge()) +
      # annotate("tile", x = sig$comp, y = -0.4, width = 0.45, height = 0.8, colour = "black", fill = "white", size = 0.5) +
      # annotate("rect", xmin = -Inf, xmax = Inf, ymin = -0.2, ymax = Inf, fill = "white") +
      # geom_bar(aes(y = amplitude - se - 0.2), stat = "identity", position = position_dodge()) + scale_fill_manual(values = c("white", "white")) +
      # new_scale_fill() +
      # annotate("label", x = sig$comp, y = -0.96, label = sig$label, size = 7, family = "Helvetica", label.size = 0) +
      geom_bar(aes(fill = condition), stat = "identity", position = position_dodge()) +
      scale_fill_viridis_d(end = 0.5) +
      geom_errorbar(aes(ymin = amplitude - se, ymax = amplitude + se), position = position_dodge(width = 0.9), width = 0.5) +
      annotate("text", x = sig$comp, y = ymin, label = sig$label, size = 6, family = "Helvetica") +
      geom_hline(yintercept = 0) +
      coord_cartesian(ylim = c(ymin, ymin + 7)) +
      ylab("ROI ampl.\n(µV)") +
      scale_y_continuous(breaks = seq(trunc(ymin), trunc(ymin) + 6, 2)) +
      theme_classic() +
      theme(legend.position = "none",
            panel.grid = element_blank(),
            axis.ticks = element_line(color = "black"),
            axis.title.x = element_blank(),
            axis.title.y = element_text(family = "Helvetica", color = "black", size = 10),
            axis.text = element_text(family = "Helvetica", color = "black", size = 10),
            plot.margin = margin(t = 0.3, r = 0, b = 0.4, l = 0.2, "cm"))})
  plot_grid(parts[[1]], NULL, parts[[2]], NULL, parts[[3]], nrow = 1, rel_widths = c(10, 1, 10, 1, 10))}

# Define function to plot ERP waveforms and topographies
plot_erps <- function(comps, evokeds, montage, stars){
  pmap(comps, function(name, start, stop, roi){
    # N400 gets a different scale than P1 and N1
    ymin <- ifelse(name == "N400", -3, -4)
    # Loop through parts
    parts <- map(c("Pt1", "Pt2", "Pt3"), function(part){
      # Create (conditions x time points) x electrodes tibble
      data_plot <- evokeds[[part]] %>% map(function(data){
        data %>% "*"(1e6) %>% t() %>% as_tibble(.name_repair = "unique") %>% set_colnames(montage$electrode) %>%
          mutate(.time = times, roi = rowMeans(select(., all_of(roi))))}) %>%
        bind_rows(.id = "condition")
      # Prepare waveform
      wave <- ggplot(data = data_plot, aes(x = .time, y = roi, color = condition)) +
        annotate("rect", xmin = start, xmax = stop, ymin = -Inf, ymax = ymin + 12, fill = "gray90")
      # Shade significant area
      star <- stars[[name]][[part]]
      if (!is.na(star)){
        wave <- wave + geom_ribbon(data = data_plot %>% filter(.time >= start & .time <= stop) %>%
                                     group_by(.time) %>% summarise(ymin = min(roi), ymax = max(roi)),
                                   aes(x = .time, xmin = start, xmax = stop, ymin = ymin, ymax = ymax),
                                   inherit.aes = FALSE, fill = viridisLite::viridis(n = 1, begin = 1))} #+
          #annotate("text", label = star, x = start + (stop - start)/2, y = -3.2, size = 7, family = "Helvetica")}
      # Add waves and styling
      wave <- wave +
        annotate("segment", x = -200, xend = 800, y = 0, yend = 0) +
        annotate("segment", x = 0, xend = 0, y = ymin, yend = ymin + 12) +
        annotate("segment", x = seq(-100, 700, 200), xend = seq(-100, 700, 200), y = -0.3, yend = 0) +
        annotate("segment", x = -12, xend = 0, y = seq(-2, 8, 4), yend = seq(-2, 8, 4)) +
        annotate("text", x = seq(-100, 700, 200), y = -0.9, label = seq(-100, 700, 200), size = 10/.pt, family = "Helvetica") +
        annotate("text", x = -20, y = seq(-2, 8, 4), label = seq(-2, 8, 4), size = 10/.pt, family = "Helvetica", hjust = 1) +
        annotate("text", x = 400, y = ymin + 0.8, label = "Time (ms)", size = 10/.pt, family = "Helvetica", lineheight = 0.9) +
        annotate("text", x = -100, y = 4, label = paste(name, "ampl.\n(µV)"), size = 10/.pt, family = "Helvetica", angle = 90, lineheight = 0.9) +
        geom_line() +
        scale_color_viridis_d(end = 0.5) +
        coord_cartesian(xlim = c(-200, 800), ylim = c(ymin, ymin + 14), expand = FALSE) +
        theme_void() +
        theme(legend.position = "none")
      # Plot topography
      topo <- data_plot %>% filter(.time >= start & .time <= stop) %>%
        group_by(condition) %>% summarise(across(montage$electrode, mean)) %>%
        pivot_longer(-condition) %>% pivot_wider(names_from = condition) %>%
        transmute(amplitude = Insight - Naive) %>% bind_cols(montage) %>%
        eegUtils::topoplot(limits = c(-1, 1), palette = "viridis", contour = FALSE, highlights = roi, scaling = 0.1) +
        theme(legend.position = "none")
      topo$layers[[3]]$aes_params$size <- topo$layers[[4]]$aes_params$size <- topo$layers[[5]]$aes_params$size <- 0.6
      # Combine waveform and topography
      wave + draw_plot(topo, width = 320, height = 9, x = 500, y = ymin + 6.4)})
    # Compbine plots for the different parts
    plot_grid(parts[[1]], NULL, parts[[2]], NULL, parts[[3]], nrow = 1, rel_widths = c(10, 1, 10, 1, 10))
    # Combine plots for the different components
  }) %>% plot_grid(plotlist = ., nrow = 3)}

# Define functions to plot legends for conditions and topoplots
plot_legends <- function(){
  legend_conditions <- get_legend(tibble(Conditions = c("Insight", "Naive")) %>% ggplot(aes(x = 0, y = 0, fill = Conditions)) +
                                    geom_raster() + scale_fill_viridis_d(end = 0.5) +
                                    theme(legend.direction = "horizontal", legend.title = element_text(family = "Helvetica", size = 10, face = "bold"),
                                          legend.text = element_text(family = "Helvetica", size = 10), legend.spacing.x = unit(0.3, "cm")))
  legend_topo <- get_legend(tibble(amplitude = c(-1, 1)) %>% ggplot(aes(x = 0, y = 0, fill = amplitude)) + geom_raster() + labs(fill = "Insight - naive\nampl. (µV)") +
                              scale_fill_viridis_c(guide = guide_colorbar(ticks = FALSE, title.position = "left", title.vjust = 1, title.hjust = 0.5)) +
                              theme(legend.direction = "horizontal", legend.title = element_text(family = "Helvetica", size = 10, face = "bold"),
                                    legend.text = element_text(family = "Helvetica", size = 10), legend.key.width = unit(0.8, "cm"), legend.spacing.x = unit(0.3, "cm")))
  plot_grid(NULL, legend_conditions, legend_topo, NULL, nrow = 1, rel_widths = c(1, 3, 3, 1))}

# Apply the functions to the data from experiment 1
plot_grid(plot_trial(),
          plot_bars(data = data_exp1, stars = stars_exp1, ymin = -1.5),
          plot_erps(comps = comps, evokeds = evokeds_exp1, montage = montage, stars = stars_exp1),
          plot_legends(),
          nrow = 4, rel_heights = c(3, 2, 6, 1), labels = c("A", "B", "C", ""), label_fontfamily = "Helvetica")
```

```{r exp2-preparation}
# List of filenames for behavioral data
fnames_exp2 <- list.files("data/exp2/RT", pattern = ".txt", full.names = TRUE)

# Apply the preprocessing function
data_exp2 <- map(fnames_exp2, preproc_behav)

# Tabulate percentage of stimuli per condition
(stims_exp2 <- bind_rows(data_exp2) %>% filter(condition != "Excl_cond") %>%
    group_by(participant, condition) %>% tally() %>%
    group_by(condition) %>% summarise(mean = mean(n)/(60*3)) %>% # 60 items per condition
    mutate(mean = if_else(condition == "Excl_known", mean/2, mean))) # 120 items in total
```

```{python exp2-preprocessing}
# List of raw EEG filenames
fnames_exp2 = sorted(glob.glob('data/exp2/EEG/*.vhdr'))

# Import behavioral data from R
metadata_exp2 = r.data_exp2

# Check if preprocessing was done already (delete the file to re-run)
if os.path.exists('output/exp2-epo.fif'):
  # Load preprocessed data from file
  epochs_exp2 = mne.read_epochs('output/exp2-epo.fif', preload=True)
else:
  # Apply the preprocessing function
  epochs_exp2 = [preproc(vhdr_fname=fname, metadata=meta, **preproc_params) for fname, meta in zip(fnames_exp2, metadata_exp2)]
  # Combine epochs into a single data set
  epochs_exp2 = mne.concatenate_epochs(epochs_exp2)
  # Backup epochs to the output folder
  epochs_exp2.save('output/exp2-epo.fif')

# # Get indices of bad epochs despite ICA
# rej_exp2 = epochs_exp2.drop_log
# rej_exp2[:] = [item for item in rej_exp2 if item != ['IGNORED']]
# rej_exp2 = [i for i in range(len(rej_exp2)) if rej_exp2[i] != []]

# Apply the function to compute grand averages
evokeds_exp2, evokeds_dat_exp2 = compute_evokeds(epochs=epochs_exp2)
```

```{r exp2-analysis}
# Re-import behavioral data
data_exp2 <- py$epochs_exp2$metadata

# Factorize some columns
data_exp2 %<>% mutate(part = factor(part, levels = c("1", "2", "3")),
                      condition = factor(condition, levels = c("Insight", "Naive", "Excl_known", "Excl_cond")),
                      participant = factor(participant), item = factor(item))

# Check number of rejected epochs
rejected_exp2 <- data_exp2 %>% group_by(participant) %>% tally() %>% mutate(n = 360 - n) %>% pull(n)
mean(rejected_exp2); median(rejected_exp2); range(rejected_exp2)

# Check if ERPs were computed already (delete the file to re-run)
if (file.exists("output/exp2-erps.RDS")){
  # Load ERPs from file
  data_exp2 <- readRDS("output/exp2-erps.RDS")
} else {
  # Import epochs from Python, converting Volts to Microvolts (takes a while)
  epochs_exp2 <- py$epochs_exp2$get_data()*1e6
  # Apply the ERP function and save to output folder
  data_exp2 <- pmap_dfc(comps, compute_erps, epochs = epochs_exp2, els = els) %>%
    set_names(comps$name) %>% cbind(data_exp2, .) %T>% saveRDS("output/exp2-erps.RDS")}

# Remove any trials that don't beling to either of the two conditions
data_exp2 %<>% filter(condition %in% c("Insight", "Naive")) %>% droplevels()

# Sliding difference coding for condition (insight-naive) and part (2-1, 3-1)
contrasts(data_exp2$condition) <- ginv(contrasts_condition)
contrasts(data_exp2$part) <- ginv(contrasts_part)

# Check if models were computed already (delete the file to re-run)
if (file.exists("output/exp2-stats.RDS")){
  # Load models from file
  models_exp2 <- readRDS("output/exp2-stats.RDS")
} else {
  # Apply the modelling function and save to output folder
  models_exp2 <- map(comps$name, compute_models, formula = form_exp12, data = data_exp2, control = ctrl_params,
                     specs = specs_exp12) %>% set_names(comps$name) %T>% saveRDS("output/exp2-stats.RDS")}

# Store significance levels for plotting
stars_exp2 = list(P1 = c(Pt1 = NA, Pt2 = NA, Pt3 = NA),
                  N1 = c(Pt1 = NA, Pt2 = "*", Pt3 = NA),
                  N400 = c(Pt1 = NA, Pt2 = "***", Pt3 = NA))
```

```{r exp2-output, include=TRUE, results="asis", fig.height=9}
# Apply the function to print the table
create_table(models_exp2, stub.anova = c("Part", "Insight", "Pt. × ins."),
            stub.contrasts = c("Part 1", "Part 2", "Part 3"),
            caption = "Results of linear mixed-effects regression models for Experiment 2",
            note = "Pt. = part, ins. = insight, est. = estimate, CI = confidence interval.")

# Import grand averaged evoked potentials from Python
evokeds_exp2 <- py$evokeds_dat_exp2

# Apply the plotting functions to the data from experiment 2
plot_grid(plot_bars(data = data_exp2, stars = stars_exp2, ymin = -2.5),
          plot_erps(comps = comps, evokeds = evokeds_exp2, montage = montage, stars = stars_exp2),
          plot_legends(),
          nrow = 3, rel_heights = c(2, 6, 1), labels = c("A", "B", ""), label_fontfamily = "Helvetica")
```

```{r joint-analysis}
# Combine data from Experiments 1 and 2 (requires changing the participant IDs for Experiment 2)
data_joint <- data_exp2 %>%
  mutate(participant = fct_relabel(participant, ~ paste0(., "_2"))) %>%
  bind_rows(data_exp1, ., .id = "experiment") %>%
  mutate(experiment = as_factor(experiment))

# Sliding difference coding for experiment (2-1), condition (insight-naive), and part (2-1, 3-1)
t(contrasts_experiment <- t(cbind(c("1" = -1, "2" = 1))))
contrasts(data_joint$experiment) <- ginv(contrasts_experiment)
contrasts(data_joint$condition) <- ginv(contrasts_condition)
contrasts(data_joint$part) <- ginv(contrasts_part)

# New formula for LMMs
form_joint <- tabulate.formula(~ part*condition*experiment + (part*condition|participant) + (part*condition*experiment|item))
form_joint %<>% mutate(block = replace(block, is.na(grouping), "fixed"))

# Check if models were computed already (delete the file to re-run)
if (file.exists("output/joint-stats.RDS")){
  # Load models from file
  models_joint <- readRDS("output/joint-stats.RDS")
} else {
  # Apply the modelling function and save to output folder
  models_joint <- map(comps$name, compute_models, formula = form_joint, data = data_joint, control = ctrl_params,
                      specs = specs_exp12) %>% set_names(comps$name) %T>% saveRDS("output/joint-stats.RDS")}
```

```{r joint-output, include=TRUE, results="asis"}
# Apply the function to print the table
create_table(models_joint, stub.anova = c("Part", "Insight", "Experiment", "Pt. × ins.", "Pt. × exp.",
                                         "Ins. × exp.", "Pt. × ins. × exp."),
            stub.contrasts = c("Part 1", "Part 2", "Part 3"),
            caption = "Results of linear mixed-effects regression models for Experiments 1 and 2 combined",
            note = "Pt. = part, ins. = insight, exp. = experiment, est. = estimate, CI = confidence interval.")
```

```{r exp3-preparation, eval=FALSE}
# List of filenames for behavioral data
fnames_exp3 <- list.files("data/exp3/RT", pattern = ".txt", full.names = TRUE)

# Apply the preprocessing function
data_exp3 <- map(fnames_exp3, preproc_behav)

# Tabulate percentage of stimuli per condition
(stims_exp3 <- bind_rows(data_exp3) %>% filter(condition != "Excl_cond" & part != "4") %>%
    group_by(participant, condition) %>% tally() %>%
    group_by(condition) %>% summarise(mean = mean(n)/(112*3)) %>% # 112 items per condition
    mutate(mean = if_else(condition == "Excl_known", mean/2, mean))) # 224 items in total
```

```{python exp3-preprocessing, eval=FALSE}
# List of raw EEG filenames
fnames_exp3 = sorted(glob.glob('data/exp3/EEG/*.vhdr'))

# Import behavioral data from R
metadata_exp3 = r.data_exp3

# Update stimulus triggers
preproc_params['event_id'] = {'match/upright': 241, 'match/inverted': 242, 'mismatch/upright': 243, 'mismatch/inverted': 244}

# Check if preprocessing was done already (delete the file to re-run)
if os.path.exists('output/exp3-epo.fif'):
  # Load preprocessed data from file
  epochs_exp3 = mne.read_epochs('output/exp3-epo.fif', preload=True)
else:
  # Apply the preprocessing function
  epochs_exp3 = [preproc(vhdr_fname=fname, metadata=meta, **preproc_params) for fname, meta in zip(fnames_exp3, metadata_exp3)]
  # Combine epochs into a single data set
  epochs_exp3 = mne.concatenate_epochs(epochs_exp3)
  # Backup epochs and evokeds to the output folder
  epochs_exp3.save('output/exp3-epo.fif')

# # Get indices of bad epochs despite ICA
# rej_exp3 = epochs_exp3.drop_log
# rej_exp3[:] = [item for item in rej_exp3 if item != ['IGNORED']]
# rej_exp3 = [i for i in range(len(rej_exp3)) if rej_exp3[i] != []]
```

```{r exp3-analysis, eval=FALSE}
# Re-import behavioral data
data_exp3 <- py$epochs_exp3$metadata

# Factorize some columns
data_exp3 %<>% mutate(part = factor(part, levels = c("1", "2", "3")),
                      position = factor(position, levels = c("Inverted", "Upright")),
                      condition = factor(condition, levels = c("Insight", "Naive", "Excl_known", "Excl_cond")),
                      participant = factor(participant), item = factor(item))

# Check if ERPs were computed already (delete the file to re-run)
if (file.exists("output/exp3-erps.RDS")){
  # Load ERPs from file
  data_exp3 <- readRDS("output/exp3-erps.RDS")
} else {
  # Import epochs from Python, converting Volts to Microvolts (takes a while)
  epochs_exp3 <- py$epochs_exp3$get_data()*1e6
  # Apply the ERP function and save to output folder
  data_exp3 <- pmap_dfc(comps, compute_erps, epochs = epochs_exp3, els = els) %>%
    set_names(comps$name) %>% cbind(data_exp3, .) %T>% saveRDS("output/exp3-erps.RDS")}

# Remove any trials from part 4
data_exp3 %<>% filter(part != "4") %>% droplevels()

# Check number of rejected epochs
rejected_exp3 <- data_exp3 %>% group_by(participant) %>% tally() %>% mutate(n = 672 - n) %>% pull(n)
mean(rejected_exp3); median(rejected_exp3); range(rejected_exp3)

# Remove any trials that don't beling to either of the two conditions
data_exp3 %<>% filter(condition %in% c("Insight", "Naive")) %>% droplevels()

# Sliding difference coding for position (inverted-updright), condition (insight-naive), and part (2-1, 3-1)
t(contrasts_position <- t(cbind(c("Inverted" = 1, "Upright" = -1))))
contrasts(data_exp3$position) <- ginv(contrasts_position)
contrasts(data_exp3$condition) <- ginv(contrasts_condition)
contrasts(data_exp3$part) <- ginv(contrasts_part)

# New formula for LMMs
form_exp3 <- tabulate.formula(~ part*condition*position + (part*condition*position|participant) + (part*condition*position|item))
form_exp3 %<>% mutate(block = replace(block, is.na(grouping), "fixed"))

# New follow-up contrasts
specs_exp3 = pairwise ~ condition|position*part

# Check if models were computed already (delete the file to re-run)
if (file.exists("output/exp3-stats.RDS")){
  # Load models from file
  models_exp3 <- readRDS("output/exp3-stats.RDS")
} else {
  # Apply the modelling function and save to output folder
  models_exp3 <- map(comps$name, compute_models, formula = form_exp3, data = data_exp3, control = ctrl_params,
                     specs = specs_exp3) %>% set_names(comps$name) %T>% saveRDS("output/exp3-stats.RDS")}
```

```{r exp3-output, include=TRUE, results="asis", eval=FALSE}
# Apply the function to print the table
create_table(models_exp3, stub.anova = c("Part", "Insight", "Position", "Pt. × ins.", "Pt. × pos.",
                                        "Ins. × pos.", "Pt. × ins. × pos."),
            stub.contrasts = c("Part 1, inverted", "Part 1, upright", "Part 2, inverted",
                               "Part 2, upright", "Part 3, inverted", "Part 3, upright"),
            caption = "Results of linear mixed-effects regression models for Experiment 3",
            note = "Pt. = part, ins. = insight, pos. = position, est. = estimate, CI = confidence interval.")
```

\newpage

# References

```{=tex}
\begingroup
\setlength{\parindent}{-0.5in}
\setlength{\leftskip}{0.5in}
```
::: {#refs custom-style="Bibliography"}
:::

\endgroup
